<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Aplicación de Monitoreo de Red Basada en ARM para Raspberry Pi y arquitecturas ARM. Creado por Fernando Valenzuela." />
  <title>Aplicación de Monitoreo de Red Basada en ARM</title>
  <link rel="icon" href="https://upload.wikimedia.org/wikipedia/commons/c/cb/Raspberry_Pi_Logo.svg" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet">
  <style>
    body {
      margin: 0;
      font-family: "Inter", system-ui, sans-serif;
      background: #0d1117;
      color: #e6edf3;
      line-height: 1.6;
    }
    header {
      text-align: center;
      padding: 4rem 1rem 2rem;
      background: linear-gradient(180deg, #161b22, #0d1117);
    }
    header h1 {
      font-size: 2.5rem;
      color: #58a6ff;
      margin-bottom: 0.5rem;
    }
    header p {
      color: #a0aec0;
      max-width: 700px;
      margin: 0 auto;
      font-size: 1.1rem;
    }

    :root {
	--background-color: #000;
	--text-color: #fff;

	--tv-background: #777;
	--tv-border: 0.2rem outset #555;

	--btn-background: #e11;
	--btn-hover-background: #f56;
	--btn-border: 1px solid #a00;
	--btn-shadow: 1px 1px 4px 2px #0003;
	--btn-active-inset: inset 0 0 5px 2px #0004;
}

/* All-purpose Sliders */

* {
	box-sizing: border-box;
}

html {
	font-size: 16px;
}

body {
	margin: 0;
	background-color: var(--background-color);
	color: var(--text-color);
	font-family: "Roboto Condensed", Arial, sans-serif;
}

h1 {
	font-size: 1.5rem;
}

button {
	padding: 0.5rem;
	background-color: var(--btn-background);
	border: none;
	color: #fff;
	border-radius: 3px;
	box-shadow: var(--btn-shadow);
	text-align: center;
	font-size: 1rem;
	font-family: inherit;
	cursor: pointer;
}
button:hover {
	background-color: var(--btn-hover-background);
}
button:active {
	background-color: var(--btn-background);
	box-shadow: var(--btn-shadow), var(--btn-active-inset);
}

/* Slideshow Hero: The base container for the slideshow. */
.slideshow {
	position: relative;
	width: calc(100vw - 40px);
	min-width: 280px;
	max-width: 800px;
	height: calc(100lvh - 40px);
	margin: 20px auto;
	padding: 1.5rem 1.5rem 4rem;
	background-color: var(--tv-background);
	border: var(--tv-border);
	border-radius: 8px;
}

/* Slideshow Item: Used as a container for slideshow content. */
@keyframes scanline-scroll {
	0% {
		background-position-y: 0;
	}
	100% {
		background-position-y: 2.75rem;
	}
}

@keyframes transition-static {
	0% {
		background-position: 0 0;
	}
	25% {
		background-position: 40px -532px;
	}
	50% {
		background-position: -1230px 55432px;
	}
	75% {
		background-position: 120px 1362px;
	}
	100% {
		background-position: -1523px 6524px;
	}
}

.slideshow-item {
	display: none;
	position: relative;
	width: 100%;
	height: 100%;
	overflow: hidden;
	border: var(--tv-border);
	border-style: inset;
	border-radius: 6px;
	font-family: "Press Start 2P", Arial, sans-serif;
	font-weight: 700;
	text-stroke: 1px #000;
	-webkit-text-stroke: 1px #000;
}

.slideshow-item::after {
	content: "";
	display: block;
	position: absolute;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;

	/* Outer Screen Gradient */
	box-shadow: inset 0 0.5rem 4.5rem 2.2rem #0009;

	/* Scanline Effect */
	background: repeating-linear-gradient(
			0deg,
			#0000 0 2.25rem,
			#0002 2.25rem 2.75rem
		)
		fixed;
	animation: 0.9s linear infinite scanline-scroll;
}
.slideshow-item[transitioning]::after {
	/* Transition Static Effect */
	background: repeating-radial-gradient(
			circle at center,
			#000 0 0.001px,
			#0000 0.001px 0.002px
		),
		repeating-conic-gradient(
			at center,
			#aaa 0deg 0.001deg,
			#fff 0.001deg 0.002deg
		);
	animation: 0.2s linear infinite transition-static;
}
.slideshow-item.active {
	display: block;
}

.slideshow-item div {
	width: 100%;
	height: 100%;
}

.slideshow-item h1 {
	position: absolute;
	bottom: 2rem;
	left: 1rem;
	margin: 0;
}

.background {
	display: block;
	width: 100%;
	height: 100%;
	object-fit: cover;
}

/* Slideshow Buttons: Used to advance to the next or previous slide. */
.slideshow-btn {
	position: absolute;
	bottom: 1rem;
	z-index: 3;
	width: 3.5rem;
	transition: all 0.15s;
}
.slideshow-btn.prev {
	left: 1rem;
}
.slideshow-btn.next {
	right: 1rem;
}

/* Slideshow Bubbles: Used for precise navigation.*/
.slideshow-bubbles {
	display: flex;
	gap: 0.5rem;
	transform: translateX(-50%);
	position: absolute;
	bottom: 1rem;
	left: 50%;
	z-index: 3;
}

.slide-bubble {
	position: relative;
	width: 1.5rem;
	height: 1.5rem;
	background-color: #000;
	border: var(--tv-border);
	border-radius: 1.5rem;
	box-shadow: var(--btn-shadow);
	cursor: pointer;
	transition: all 0.15s;
}
.slide-bubble:hover {
	background-color: var(--btn-hover-background);
	border: var(--tv-border);
}
.slide-bubble:active,
.slide-bubble.active {
	background-color: var(--btn-background);
}

/* Button Glow Effect */
.slide-bubble::after {
	content: "";
	transform: translate(-50%, -50%);
	position: absolute;
	top: 50%;
	left: 50%;
	width: 100%;
	height: 100%;
	border: 0.1rem solid #f110;
	border-radius: 1.5rem;
	transition: all 0.15s;
}
.slide-bubble:hover::after,
.slide-bubble.active::after {
	border: 0.1rem solid #f117;
}

/* Resize Everything for Larger Screens */
@media (min-width: 650px) {
	h1 {
		font-size: 2rem;
	}

	.slideshow {
		padding: 4rem;
	}
}

    section {
      max-width: 900px;
      margin: 2rem auto;
      padding: 1rem 2rem;
      background: #161b22;
      border-radius: 12px;
      box-shadow: 0 0 12px rgba(0, 0, 0, 0.4);
    }
    section h2 {
      color: #58a6ff;
      margin-top: 1rem;
    }
    ul {
      padding-left: 1.2rem;
    }
    .tags span {
      display: inline-block;
      background: #21262d;
      color: #58a6ff;
      padding: 0.3rem 0.6rem;
      border-radius: 6px;
      margin-right: 0.4rem;
      font-size: 0.9rem;
    }
    footer {
      text-align: center;
      padding: 2rem;
      color: #8b949e;
      border-top: 1px solid #21262d;
      margin-top: 3rem;
    }
    a {
      color: #58a6ff;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    .project-links a {
      display: inline-block;
      margin-right: 1rem;
      background: #21262d;
      padding: 0.6rem 1rem;
      border-radius: 8px;
      transition: 0.2s;
    }
    .project-links a:hover {
      background: #30363d;
    }
  </style>
</head>
<body>

  <header>
    <h1>Aplicación de Monitoreo de Red Basada en ARM</h1>
    <p>
      Transforma tu Raspberry Pi en un Centro de Operaciones de Red (NOC) completamente funcional.  
      Visibilidad en tiempo real de servicios, análisis de tráfico y control de interfaz — optimizado para arquitecturas ARM.
    </p>
  </header>

import React, { useCallback, useEffect, useState } from "https://esm.sh/react";
import ReactDOM from "https://esm.sh/react-dom/client";

const TIME_TIL_NEXT_SLIDE = 5000;

/**
	Returns `x` mod `y`. Apparently JavaScript modulo doesn't process negative numbers correctly.
	
	This solution was found from this article:
	https://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm
	
	@param {number} x
	@param {number} y
	@returns {number}
*/
function mod(x, y) {
	return ((x % y) + y) % y;
}

/**
	A hero slideshow element. This element should contain a set of slides to display.
	
	@param {Object} props
	@param {(JSX.Element | JSX.Element[])?} props.children
	@returns {JSX.Element}
*/
function Slideshow({ children }) {
	let slides = children;
	if (!(slides instanceof Array)) {
		slides = [children];
	}

	const [lastSlideIndex, setLastSlideIndex] = useState(0);
	const [slideIndex, setSlideIndex] = useState(0);
	const [transitioning, setTransitioning] = useState(false);

	/**
		Sets the slide to the given value.
		@type {(newSlideIndex: number) => void}
	*/
	const gotoSlide = useCallback(
		(newSlideIndex) => {
			if (!transitioning) {
				setTransitioning(true);

				setTimeout(() => {
					setTransitioning(false);
					setSlideIndex((currentSlide) => {
						setLastSlideIndex(currentSlide);
						return mod(newSlideIndex, slides.length);
					});
				}, 100);
			}
		},
		[slides, slideIndex, transitioning]
	);

	/**
		Advances to the next slide of the slideshow.
		@type {() => void}
	*/
	const advanceNextSlide = useCallback(() => {
		// This is probably not the most React way to do this but it works.
		gotoSlide(slideIndex + 1);
	}, [slides, slideIndex]);

	/**
		Advances to the previous slide of the slideshow.
		@type {() => void}
	*/
	const advancePrevSlide = useCallback(() => {
		gotoSlide(slideIndex - 1);
	}, [slides, slideIndex]);

	useEffect(() => {
		const advanceInterval = setInterval(() => {
			advanceNextSlide();
		}, TIME_TIL_NEXT_SLIDE);

		return () => {
			clearInterval(advanceInterval);
		};
	}, [slideIndex]);

	return (
		<div className="slideshow">
			{slides &&
				slides.map((slide, idx) => (
					<div
						className={
							idx === slideIndex ? "slideshow-item active" : "slideshow-item"
						}
						key={idx}
						transitioning={transitioning && "true"}
					>
						{slide}
					</div>
				))}

			<button className="slideshow-btn next" onClick={advanceNextSlide}>
				NEXT
			</button>
			<button className="slideshow-btn prev" onClick={advancePrevSlide}>
				PREV
			</button>

			<div className="slideshow-bubbles">
				{slides &&
					slides.map((_, idx) => (
						<button
							type="button"
							className={idx === slideIndex ? "slide-bubble active" : "slide-bubble"}
							onClick={() => gotoSlide(idx)}
						/>
					))}
			</div>
		</div>
	);
}

function App() {
	return (
		<Slideshow>
			<div>
				<img
					className="background"
					src="https://images.unsplash.com/photo-1579309401389-a2476dddf3d4?q=80&w=1170&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"
					alt="A closeup of Pac-Man."
				/>
				<h1>Tenemos cientos de enlaces activos!!</h1>
			</div>
			<div>
				<img
					className="background"
					src="https://images.unsplash.com/photo-1538511625527-e893585d8ed2?q=80&w=1170&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"
					alt="Bowling lane."
				/>
				<h1>Puertos abiertos!</h1>
			</div>
			<div>
				<img
					className="background"
					src="https://images.unsplash.com/photo-1676515725176-275bb09cc59b?q=80&w=1170&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"
					alt="Delicious burgers."
				/>
				<h1>Tambien nos gustaría tener control del tr</h1>
			</div>
		</Slideshow>
	);
}

ReactDOM.createRoot(document.getElementById("app")).render(<App />);


  <section>
    <h2>⚙️ Gestión Integral de Puertos y Servicios</h2>
    <ul>
      <li><b>Puertos y Protocolos:</b> Monitorea servicios TCP y UDP (SSH:22, DNS:53, HTTP:80, HTTPS:443).</li>
      <li><b>Seguimiento de Procesos y PID:</b> Asigna puertos abiertos a sus procesos exactos (ej. <code>dev-server</code>, PID 5678).</li>
      <li><b>Vinculación de Interfaz:</b> Muestra en qué interfaz de red escucha cada servicio (ej. <code>0.0.0.0</code> o <code>127.0.0.1</code>).</li>
      <li><b>Control Centralizado:</b> Incluye herramientas de acción para gestionar, bloquear o reiniciar servicios directamente desde la interfaz.</li>
    </ul>
  </section>

  <section>
    <h2>🌐 Análisis Visual de Flujo de Tráfico</h2>
    <ul>
      <li><b>Segmentación de Tráfico:</b> Categoriza flujos por región o tipo (Social-América, Norteamérica, África).</li>
      <li><b>Enrutamiento a Nivel de Servicio:</b> Visualiza conexiones desde el Hub de Tráfico IPT a puertos específicos (ej. <code>rope:600</code>, <code>custom-app:8080</code>).</li>
      <li><b>Representación Proporcional:</b> El grosor de las líneas refleja el volumen de tráfico y los niveles de actividad.</li>
    </ul>
  </section>

  <section>
    <h2>🍓 Optimizado para Raspberry Pi y ARM</h2>
    <ul>
      <li><b>Operación de Bajo Consumo:</b> Funciona 24/7 con consumo mínimo de energía.</li>
      <li><b>Económico:</b> Construido para hardware ARM accesible como Raspberry Pi.</li>
      <li><b>Compacto y Portátil:</b> Ligero, desplegable en cualquier lugar de la red.</li>
    </ul>
  </section>

  <section>
    <h2>🔧 Pila Técnica</h2>
    <div class="tags">
      <span>React</span>
      <span>Vite</span>
      <span>Bun</span>
      <span>Cloudflare Workers</span>
      <span>ARM</span>
      <span>Raspberry Pi</span>
    </div>
    <div class="project-links" style="margin-top: 1rem;">
      <a href="https://rpi-network-security-dashboard.pages.dev" target="_blank"><i class="fas fa-external-link-alt"></i> Demo en Vivo</a>
      <a href="https://github.com/Nagorik11/rpi-network-security-dashboard" target="_blank"><i class="fab fa-github"></i> Repositorio GitHub</a>
    </div>
  </section>

  <footer>
    <p>© 2025 Fernando Valenzuela — Construido para Seguridad de Red e Innovación ARM.</p>
  </footer>

  <script>
    // Carousel functionality
    (function() {
      const track = document.querySelector('.carousel-track');
      const slides = Array.from(track.children);
      const prevButton = document.querySelector('.carousel-button.prev');
      const nextButton = document.querySelector('.carousel-button.next');
      const dotsNav = document.querySelector('.carousel-dots');
      const dots = Array.from(dotsNav.children);
      let currentIndex = 0;

      function goToSlide(index) {
        if (index < 0) index = slides.length - 1;
        if (index >= slides.length) index = 0;
        track.style.transform = 'translateX(-' + (index * 100) + '%)';
        dots.forEach((d, i) => {
          d.classList.toggle('active', i === index);
          d.setAttribute('aria-selected', i === index ? 'true' : 'false');
        });
        currentIndex = index;
      }

      prevButton.addEventListener('click', () => {
        goToSlide(currentIndex - 1);
        resetAutoplay();
      });
      nextButton.addEventListener('click', () => {
        goToSlide(currentIndex + 1);
        resetAutoplay();
      });

      dots.forEach((dot, i) => {
        dot.addEventListener('click', () => {
          goToSlide(i);
          resetAutoplay();
        });
      });

      // Autoplay
      let autoplayInterval = setInterval(() => goToSlide(currentIndex + 1), 5000);
      function resetAutoplay() {
        clearInterval(autoplayInterval);
        autoplayInterval = setInterval(() => goToSlide(currentIndex + 1), 5000);
      }

      // Initialize
      goToSlide(0);
    })();
  </script>

</body>
</html>
